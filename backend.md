`# Building a Complete Backend with Supabase

Questo documento fornisce una guida completa per la creazione di un backend robusto, scalabile e sicuro utilizzando Supabase. Tratteremo tutto, dalla configurazione iniziale del progetto e la progettazione del database all'implementazione dell'autenticazione, alla creazione di API e al deployment.

## Indice

1.  [Introduzione a Supabase](#1-introduzione-a-supabase)
2.  [Configurazione Iniziale del Progetto](#2-configurazione-iniziale-del-progetto)
3.  [Creazione e Gestione del Database](#3-creazione-e-gestione-del-database)
    *   [Schema delle Tabelle](#schema-delle-tabelle)
    *   [Relazioni](#relazioni)
    *   [Row Level Security (RLS)](#row-level-security-rls)
4.  [Implementazione dell'Autenticazione](#4-implementazione-dellautenticazione)
    *   [Configurazione](#configurazione)
    *   [Gestione dei Profili Utente](#gestione-dei-profili-utente)
    *   [Flussi di Autenticazione (Esempi di Codice)](#flussi-di-autenticazione-esempi-di-codice)
5.  [API e Funzionalità Backend](#5-api-e-funzionalità-backend)
    *   [API Auto-generate (CRUD)](#api-auto-generate-crud)
    *   [Edge Functions (Logica Custom)](#edge-functions-logica-custom)
    *   [Storage](#storage)
    *   [Realtime](#realtime)
6.  [Best Practices e Sicurezza](#6-best-practices-e-sicurezza)
7.  [Script SQL Completo](#7-script-sql-completo)
8.  [Deployment e Gestione](#8-deployment-e-gestione)

---

### 1. Introduzione a Supabase

Supabase è una piattaforma open source che si presenta come un'alternativa a Firebase. Fornisce un set completo di strumenti per costruire rapidamente backend, senza la necessità di scrivere codice boilerplate. I suoi componenti principali includono:

*   **Database PostgreSQL:** Un database SQL completo e potente, che costituisce il cuore di ogni progetto Supabase.
*   **Autenticazione:** Un servizio integrato per gestire utenti, login (con password, social, magic link) e sessioni.
*   **API Auto-generate:** Supabase ispeziona lo schema del tuo database e genera automaticamente API RESTful e GraphQL sicure.
*   **Storage:** Per archiviare e servire file di grandi dimensioni come immagini, video o documenti.
*   **Edge Functions:** Funzioni serverless basate su Deno per eseguire logica backend custom.
*   **Realtime:** Per ascoltare le modifiche al database (insert, update, delete) in tempo reale.

---

### 2. Configurazione Iniziale del Progetto

1.  **Crea un Progetto:** Vai su [supabase.com](https://supabase.com), registrati e crea un nuovo progetto. Scegli un nome, genera una password sicura per il database e seleziona una regione.
2.  **Trova le Tue API Keys:** Una volta creato il progetto, vai su `Project Settings` > `API`. Qui troverai:
    *   **Project URL:** L'URL univoco per le tue API Supabase.
    *   **`anon` (public) key:** Questa chiave è sicura da usare nel codice frontend. È utilizzata per l'accesso anonimo e autenticato, rispettando le policy di Row Level Security (RLS).
3.  **Configura il Tuo Frontend:** Installa la libreria client di Supabase.

    ```bash
    npm install @supabase/supabase-js
    ```

    Crea un file client per inizializzare Supabase nella tua applicazione:

    ```javascript
    // src/services/supabaseClient.js
    import { createClient } from '@supabase/supabase-js'

    const supabaseUrl = 'YOUR_SUPABASE_PROJECT_URL'
    const supabaseAnonKey = 'YOUR_SUPABASE_ANON_KEY'

    export const supabase = createClient(supabaseUrl, supabaseAnonKey)
    ```

---

### 3. Creazione e Gestione del Database

Questa sezione descrive come strutturare il database PostgreSQL per l'applicazione di forecasting.

#### Schema delle Tabelle

Creeremo le seguenti tabelle: `business_units`, `clients`, `profiles` (per i dati utente), `forecasts` e `comments`. Puoi crearle tramite l'interfaccia **Table Editor** nella dashboard di Supabase o eseguendo lo script SQL fornito di seguito.

**Script SQL per la Creazione delle Tabelle:**

```sql
-- Tabella per le Business Units
CREATE TABLE public.business_units (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  name TEXT NOT NULL UNIQUE,
  created_at TIMESTAMPTZ DEFAULT NOW()
);

-- Tabella per i Clienti
CREATE TABLE public.clients (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  name TEXT NOT NULL,
  business_unit_id BIGINT REFERENCES public.business_units(id) ON DELETE SET NULL,
  created_at TIMESTAMPTZ DEFAULT NOW()
);

-- Tabella per i Profili Utente (collegata a auth.users)
CREATE TABLE public.profiles (
  id UUID PRIMARY KEY REFERENCES auth.users(id) ON DELETE CASCADE,
  full_name TEXT,
  role TEXT NOT NULL DEFAULT 'Data Entry',
  assigned_client_ids BIGINT[],
  assigned_business_unit_ids BIGINT[]
);

-- Tabella per le Previsioni (Forecasts)
CREATE TABLE public.forecasts (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  month INT NOT NULL CHECK (month >= 1 AND month <= 12),
  year INT NOT NULL,
  client_id BIGINT NOT NULL REFERENCES public.clients(id) ON DELETE CASCADE,
  business_unit_id BIGINT NOT NULL REFERENCES public.business_units(id) ON DELETE CASCADE,
  declared_budget NUMERIC(12, 2) DEFAULT 0.00,
  budget NUMERIC(12, 2) DEFAULT 0.00,
  forecast NUMERIC(12, 2) DEFAULT 0.00,
  user_id UUID NOT NULL REFERENCES public.profiles(id),
  last_modified TIMESTAMPTZ DEFAULT NOW(),
  status TEXT NOT NULL DEFAULT 'Bozza', -- 'Bozza' o 'Approvato'
  UNIQUE (month, year, client_id) -- Un cliente può avere solo una previsione per mese/anno
);

-- Tabella per i Commenti
CREATE TABLE public.comments (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  forecast_id BIGINT NOT NULL REFERENCES public.forecasts(id) ON DELETE CASCADE,
  user_id UUID NOT NULL REFERENCES public.profiles(id),
  text TEXT NOT NULL,
  created_at TIMESTAMPTZ DEFAULT NOW()
);`

### **Relazioni**

- **One-to-Many:** business_units ha molti clients e molti forecasts.
- **One-to-One:** auth.users ha una relazione uno-a-uno con public.profiles, collegati tramite l'ID utente (UUID).
- **Many-to-One:** forecasts appartiene a un client e a una business_unit. comments appartiene a un forecast.

### **Row Level Security (RLS)**

RLS è la feature di sicurezza più importante di Supabase. Ti permette di definire policy SQL che determinano quali righe gli utenti possono leggere, inserire, aggiornare o eliminare.

**Prima di tutto, abilita RLS su ogni tabella!** Puoi farlo nell'UI o con SQL:

codeSQL

`ALTER TABLE public.business_units ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.clients ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.profiles ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.forecasts ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.comments ENABLE ROW LEVEL SECURITY;`

**Esempi di Policy:**

codeSQL

- `- Helper function per ottenere il ruolo dell'utente corrente
CREATE OR REPLACE FUNCTION get_my_role()
RETURNS TEXT AS $$ SELECT role FROM public.profiles WHERE id = auth.uid();
$$ LANGUAGE sql SECURITY DEFINER;
-- Policy per i Profili: gli utenti possono vedere e modificare solo il proprio profilo.
CREATE POLICY "Users can manage their own profile" ON public.profiles FOR ALL USING (auth.uid() = id);
-- Policy per Clienti e BU: tutti gli utenti autenticati possono leggerli. Solo gli admin possono modificarli.
CREATE POLICY "Authenticated users can read" ON public.business_units FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Admins can manage" ON public.business_units FOR ALL USING (get_my_role() = 'Administrator');
CREATE POLICY "Authenticated users can read" ON public.clients FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Admins can manage" ON public.clients FOR ALL USING (get_my_role() = 'Administrator');
-- Policy per le Previsioni (Forecasts)
CREATE POLICY "Admins can see all forecasts" ON public.forecasts FOR SELECT USING (get_my_role() = 'Administrator');
CREATE POLICY "Data Entry users can see their assigned forecasts" ON public.forecasts FOR SELECT USING ( get_my_role() = 'Data Entry' AND business_unit_id = ANY (SELECT unnest(assigned_business_unit_ids) FROM public.profiles WHERE id = auth.uid()) );
CREATE POLICY "Users can update forecasts they can see" ON public.forecasts FOR UPDATE USING ( ( get_my_role() = 'Administrator' OR ( get_my_role() = 'Data Entry' AND business_unit_id = ANY (SELECT unnest(assigned_business_unit_ids) FROM public.profiles WHERE id = auth.uid()) ) ) AND status <> 'Approvato' -- Non si può modificare se approvato (a meno che non sia un admin) ) WITH CHECK (user_id = auth.uid()); -- Quando si aggiorna, si imposta user_id su se stessi
CREATE POLICY "Admins can update approved forecasts" ON public.forecasts FOR UPDATE USING (get_my_role() = 'Administrator');
-- E così via per INSERT e DELETE...`

---

### **4. Implementazione dell'Autenticazione**

### **Configurazione**

1. Vai su Authentication > Providers nella dashboard e abilita i provider che desideri (es. Email).
2. In Authentication > Settings, puoi configurare opzioni come la disabilitazione delle registrazioni pubbliche, i template delle email, ecc.

### **Gestione dei Profili Utente**

Per collegare i dati di autenticazione (auth.users) con i dati della tua app (public.profiles), usa un **trigger** che crea un nuovo profilo ogni volta che un utente si registra.

codeSQL

- `- Funzione che crea un profilo quando un utente si registra
CREATE OR REPLACE FUNCTION public.handle_new_user()
RETURNS TRIGGER AS $$
BEGIN INSERT INTO public.profiles (id, full_name, role) VALUES ( new.id, new.raw_user_meta_data->>'full_name', 'Data Entry' -- Ruolo di default ); RETURN new;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;
-- Trigger che esegue la funzione dopo ogni insert in auth.users
CREATE TRIGGER on_auth_user_created AFTER INSERT ON auth.users FOR EACH ROW EXECUTE PROCEDURE public.handle_new_user();`

### **Flussi di Autenticazione (Esempi di Codice)**

Usa la libreria supabase-js nel tuo frontend.

**Registrazione (Sign Up):**

codeJavaScript

`async function signUp(email, password, fullName) {
  const { data, error } = await supabase.auth.signUp({
    email: email,
    password: password,
    options: {
      data: {
        full_name: fullName, // Questi dati vanno in raw_user_meta_data
      }
    }
  });
  if (error) console.error('Error signing up:', error.message);
  return { data, error };
}`

**Login:**

codeJavaScript

`async function signIn(email, password) {
  const { data, error } = await supabase.auth.signInWithPassword({
    email: email,
    password: password,
  });
  if (error) console.error('Error signing in:', error.message);
  return { data, error };
}`

**Gestione Sessione:**

codeJavaScript

`// Ascolta i cambiamenti di stato dell'autenticazione
supabase.auth.onAuthStateChange((event, session) => {
  if (event === 'SIGNED_IN') {
    console.log('User signed in:', session.user);
    // Aggiorna lo stato della tua UI
  }
  if (event === 'SIGNED_OUT') {
    console.log('User signed out');
    // Aggiorna lo stato della tua UI
  }
});`

---

### **5. API e Funzionalità Backend**

### **API Auto-generate (CRUD)**

Supabase ti permette di interagire con il database usando una sintassi semplice e intuitiva.

**Leggere dati (SELECT):**

codeJavaScript

`async function getForecasts(month, year) {
  const { data: forecasts, error } = await supabase
    .from('forecasts')
    .select(`
      id,
      month,
      year,
      budget,
      forecast,
      status,
      clients ( id, name ),
      business_units ( id, name )
    `)
    .eq('month', month)
    .eq('year', year);

  if (error) console.error('Error fetching forecasts:', error);
  return forecasts;
}`

**Inserire dati (INSERT):**

codeJavaScript

`async function addComment(forecastId, userId, text) {
  const { data, error } = await supabase
    .from('comments')
    .insert([
      { forecast_id: forecastId, user_id: userId, text: text }
    ])
    .select();

  if (error) console.error('Error adding comment:', error);
  return data;
}`

**Aggiornare dati (UPDATE):**

codeJavaScript

`async function updateForecastValue(forecastId, newForecastValue) {
  const { data, error } = await supabase
    .from('forecasts')
    .update({ forecast: newForecastValue, last_modified: new Date().toISOString() })
    .eq('id', forecastId)
    .select();

  if (error) console.error('Error updating forecast:', error);
  return data;
}`

### **Edge Functions (Logica Custom)**

Per logica complessa che non può essere gestita con RLS o viste del database.

1. **Installa la Supabase CLI:** npm install supabase --save-dev
2. **Inizializza il progetto:** npx supabase init
3. **Crea una nuova funzione:** npx supabase functions new send-summary
4. **Scrivi il codice della funzione (in supabase/functions/send-summary/index.ts):**codeTypeScript
    
    `// Esempio: Invia un riepilogo via email
    import { serve } from "https://deno.land/std@0.168.0/http/server.ts";
    import { createClient } from "https://esm.sh/@supabase/supabase-js@2";
    
    serve(async (req) => {
      try {
        const supabaseClient = createClient(
          Deno.env.get("SUPABASE_URL")!,
          Deno.env.get("SUPABASE_SERVICE_ROLE_KEY")!
        );
    
        // Logica per recuperare i dati e inviare un'email...
        const { data, error } = await supabaseClient.from('forecasts').select('*').limit(10);
        if (error) throw error;
    
        return new Response(JSON.stringify({ message: "Summary sent!", data }), {
          headers: { "Content-Type": "application/json" },
        });
      } catch (error) {
        return new Response(String(error?.message ?? error), { status: 500 });
      }
    });`
    
5. **Esegui il deploy:** npx supabase functions deploy send-summary

### **Storage**

Per caricare file, come ad esempio allegati ai commenti.

1. **Crea un Bucket:** Vai su Storage e crea un nuovo bucket (es. forecast-attachments).
2. **Imposta le Policy del Bucket:** Definisci chi può caricare, scaricare o eliminare file.

**Esempio di Upload:**

codeJavaScript

`async function uploadAttachment(file, forecastId) {
  const filePath = `public/${forecastId}/${file.name}`;

  const { data, error } = await supabase
    .storage
    .from('forecast-attachments')
    .upload(filePath, file);

  if (error) {
    console.error('Error uploading file:', error);
  } else {
    console.log('File uploaded successfully:', data.path);
  }
}`

### **Realtime**

Ascolta le modifiche al database in tempo reale.

codeJavaScript

`// Esempio: Ascolta i nuovi commenti per un forecast specifico
const forecastId = 123;

const channel = supabase.channel(`comments-for-forecast-${forecastId}`);

channel
  .on(
    'postgres_changes',
    {
      event: 'INSERT',
      schema: 'public',
      table: 'comments',
      filter: `forecast_id=eq.${forecastId}`
    },
    (payload) => {
      console.log('New comment received!', payload.new);
      // Aggiungi il nuovo commento alla tua UI
    }
  )
  .subscribe();

// Per smettere di ascoltare:
// supabase.removeChannel(channel);`

---

### **6. Best Practices e Sicurezza**

- **Abilita SEMPRE RLS:** Non esporre mai dati senza Row Level Security abilitata.
- **Usa service_role_key solo lato server:** Questa chiave bypassa RLS ed è estremamente potente. Non includerla mai nel codice frontend. Usala solo nelle Edge Functions o in un tuo server dedicato.
- **Definisci Policy restrittive:** Inizia con policy che negano l'accesso e poi apri selettivamente ciò che è necessario.
- **Usa Variabili d'Ambiente:** Non hardcodare mai le chiavi API nel tuo codice. Usa sempre variabili d'ambiente (.env).
- **Backup:** Supabase gestisce i backup automatici, ma considera di fare backup manuali prima di modifiche importanti allo schema.
- **2FA:** Abilita l'autenticazione a due fattori sul tuo account Supabase.

---

### **7. Script SQL Completo**

Per comodità, ecco uno script completo per configurare le tabelle, i profili utente e le policy di base. Puoi eseguirlo nell'**SQL Editor** della dashboard di Supabase.

[Includi una versione consolidata e pulita degli script SQL menzionati sopra]

---

### **8. Deployment e Gestione**

- **Ambienti:** Supabase non ha ancora un sistema di ambienti integrato (staging/produzione) come altre piattaforme, ma puoi gestire la cosa creando organizzazioni separate per ogni ambiente. La Supabase CLI è essenziale per migrare lo schema tra ambienti.
- **Migrazioni:** Usa la CLI per creare e gestire le migrazioni del database:
    - npx supabase db diff -f my_migration_name per generare una migrazione.
    - npx supabase db reset per applicare le migrazioni localmente.
- **Log e Monitoraggio:** La dashboard di Supabase fornisce strumenti per visualizzare i log delle API, delle funzioni e del database, oltre a report sull'utilizzo delle risorse.

Seguendo questa guida, sarai in grado di implementare un backend completo, sicuro e scalabile per la tua applicazione, sfruttando tutta la potenza e la semplicità di Supabase.